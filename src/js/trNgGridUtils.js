/// <reference path="../../../typings/angularjs/angular.d.ts"/>
var TrNgGrid;
(function (TrNgGrid) {
    function findChildByTagName(parent, childTag) {
        childTag = childTag.toUpperCase();
        var children = parent.children();
        for (var childIndex = 0; childIndex < children.length; childIndex++) {
            var childElement = children[childIndex];
            if (childElement.tagName === childTag) {
                return angular.element(childElement);
            }
        }
        return null;
    }
    TrNgGrid.findChildByTagName = findChildByTagName;
    ;
    function findChildIndex(child) {
        var parent = child.parent();
        var children = parent.children();
        var childIndex = 0;
        for (; childIndex < children.length && children[childIndex] === child[0]; childIndex++)
            ;
        return (childIndex >= children.length) ? -1 : childIndex;
    }
    TrNgGrid.findChildIndex = findChildIndex;
    ;
    function findChildrenByTagName(parent, childTag) {
        childTag = childTag.toUpperCase();
        var retChildren = [];
        var children = parent.children();
        for (var childIndex = 0; childIndex < children.length; childIndex++) {
            var childElement = children[childIndex];
            if (childElement.tagName === childTag) {
                retChildren.push(angular.element(childElement));
            }
        }
        return retChildren;
    }
    TrNgGrid.findChildrenByTagName = findChildrenByTagName;
    ;
    function wrapTemplatedCell(templateElement, cellTemplateDirective) {
        var childrenElements = templateElement.children();
        if (childrenElements.length !== 1 || !angular.element(childrenElements[0]).attr(cellTemplateDirective)) {
            // wrap the children of the custom template cell
            // don't attempt to add the children, there might just be verbatim text in there
            var templateWrapElement = angular.element("<div>" + templateElement.html() + "</div>").attr(cellTemplateDirective, "");
            templateElement.empty();
            templateElement.append(templateWrapElement);
        }
    }
    TrNgGrid.wrapTemplatedCell = wrapTemplatedCell;
    ;
    function log(message) {
        console.log(TrNgGrid.Constants.tableDirective + "(" + new Date().getTime() + "): " + message);
    }
    TrNgGrid.log = log;
    ;
    // due to angular limitations, the following workarounds are required
    function createRowElement() {
        return findChildByTagName(findChildByTagName(angular.element("<table><tbody><tr></tr></tbody></table>"), "tbody"), "tr");
    }
    TrNgGrid.createRowElement = createRowElement;
    function createCellElement(cellTagName) {
        return findChildByTagName(findChildByTagName(findChildByTagName(angular.element("<table><tbody><tr><" + cellTagName + "></" + cellTagName + "></tr></tbody></table>"), "tbody"), "tr"), cellTagName);
    }
    TrNgGrid.createCellElement = createCellElement;
    function fixGridCell(gridConfiguration, cellElement, cellTagName, cellElementDirectiveAttribute, rowIndex, cellIndex) {
        if (!cellElement) {
            cellElement = createCellElement(cellTagName);
            cellElement.attr(TrNgGrid.Constants.dataColumnIsAutoGeneratedAttribute, "true");
        }
        cellElement.attr(cellElementDirectiveAttribute, "");
        cellElement.attr(TrNgGrid.Constants.dataColumnRowIndexAttribute, rowIndex);
        cellElement.attr(TrNgGrid.Constants.dataColumnBatchIndexAttribute, cellIndex);
        var cellChildrenElements = cellElement.children();
        // use a better approach by checking the raw contents
        // be aware trim isn't supported in all browsers
        var isCustomized = cellChildrenElements.length || ((cellElement.html().replace(/^\s+|\s+$/gm, '')));
        if (isCustomized && cellChildrenElements.length === 0) {
            // wrap the text in a div
            var wrappedContent = angular.element("<div>" + cellElement.html() + "</div>");
            cellElement.empty();
            cellElement.append(wrappedContent);
        }
        if (isCustomized) {
            cellElement.attr(TrNgGrid.Constants.dataColumnIsCustomizedAttribute, "true");
        }
        return cellElement;
    }
    TrNgGrid.fixGridCell = fixGridCell;
    function fixGridSection(gridConfiguration, sectionElement, cellTagName, cellElementDirectiveAttribute) {
        var rowElement;
        var rowElements = findChildrenByTagName(sectionElement, "tr");
        if (!rowElements.length) {
            sectionElement.empty();
            rowElement = createRowElement();
            sectionElement.append(rowElement);
            rowElements.push(rowElement);
        }
        for (var rowIndex = 0; rowIndex < rowElements.length; rowIndex++) {
            rowElement = rowElements[rowIndex];
            var cellElement;
            var cellElements = findChildrenByTagName(rowElement, "th");
            if (!cellElements.length) {
                rowElement.empty();
                cellElement = createCellElement("th");
                rowElement.append(cellElement);
                cellElements.push(cellElement);
            }
            var isAlreadyFixed = false;
            for (var cellIndex = 0; !isAlreadyFixed && cellIndex < cellElements.length; cellIndex++) {
                cellElement = cellElements[cellIndex];
                // if the first element is fixed, we're out of here
                if (cellIndex === 0 && rowElement.attr(TrNgGrid.Constants.dataColumnIsAutoGeneratedAttribute)) {
                    isAlreadyFixed = true;
                }
                else {
                    cellElement = fixGridCell(gridConfiguration, cellElement, cellTagName, cellElementDirectiveAttribute, rowIndex, (cellIndex << 1) + 1);
                    // we'll weave some of our elements to cover the non-customized fields or cells having options on them
                    var weavedAutoElement = fixGridCell(gridConfiguration, null, cellTagName, cellElementDirectiveAttribute, rowIndex, (cellIndex + 1) << 1);
                    cellElement.after(weavedAutoElement);
                }
            }
        }
    }
    TrNgGrid.fixGridSection = fixGridSection;
    function fixTableStructure(gridConfiguration, gridElement) {
        // make sure the header is present
        var tableHeaderElement = findChildByTagName(gridElement, "thead");
        if (!tableHeaderElement) {
            tableHeaderElement = findChildByTagName(angular.element("<table><thead></thead></table"), "thead");
            gridElement.prepend(tableHeaderElement);
        }
        tableHeaderElement.attr(TrNgGrid.Constants.headerDirectiveAttribute, "");
        fixGridSection(gridConfiguration, tableHeaderElement, "th", TrNgGrid.Constants.cellHeaderDirectiveAttribute);
        // the footer follows immediately after the header
        var tableFooterElement = findChildByTagName(gridElement, "tfoot");
        if (!tableFooterElement) {
            tableFooterElement = findChildByTagName(angular.element("<table><tfoot></tfoot></table"), "tfoot");
            tableHeaderElement.after(tableFooterElement);
        }
        //tableFooterElement.attr(footerDirectiveAttribute, "");
        // the body is the last
        var tableBodyElement = findChildByTagName(gridElement, "tbody");
        if (!tableBodyElement) {
            tableBodyElement = findChildByTagName(angular.element("<table><tbody></tbody></table"), "tbody");
            tableFooterElement.after(tableBodyElement);
        }
        //tableBodyElement.attr(bodyDirectiveAttribute, "");
        // any other elements are not allowed
        angular.forEach(gridElement.children, function (element) {
            if (element !== tableHeaderElement[0] || element !== tableBodyElement[0] || element !== tableFooterElement[0]) {
                angular.element(element).remove();
                gridConfiguration.debugMode && log("Invalid extra element found inside the grid template structure: " + element.tagName);
            }
        });
        // block or allow data bindings
        //if (allowDataBindings) {
        //    tableHeaderElement.removeAttr("data-ng-non-bindable");
        //    tableFooterElement.removeAttr("data-ng-non-bindable");
        //    tableBodyElement.removeAttr("data-ng-non-bindable");
        //}
        //else {
        //    tableHeaderElement.attr("data-ng-non-bindable", "");
        //    tableFooterElement.attr("data-ng-non-bindable", "");
        //    tableBodyElement.attr("data-ng-non-bindable", "");
        //}
    }
    TrNgGrid.fixTableStructure = fixTableStructure;
})(TrNgGrid || (TrNgGrid = {}));
